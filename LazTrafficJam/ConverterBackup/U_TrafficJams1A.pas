unit U_TrafficJams1A;

{$IFDEF FPC}
  {$MODE Delphi}
{$ENDIF}

{Copyright 2001,2008 Gary Darby, Intellitech Systems Inc., www.DelphiForFun.org

 This program may be used or modified for any non-commercial purpose
 so long as this original notice remains in place.
 All other rights are reserved
 }

{ A computer version of RushHour(TM) game by Binary Arts.  This version
  features
   -- text input file containing case setups,
   -- user play,
   -- printing of jams with solution,
   -- tracking of best scores by player name, and
   -- auto-solving by computer
}

{Version 1.1 March, 2008 adds ability to solve a puzzle generated by
 Grandson Luke (included in the Intermediated level puzzles) which
 has a vehicle on the exit row, moving in the same direction as the
 red target car but blocking its exit.  The blocking car must be driven
 through (to) the Exit to clear the way before the red car can escape.}


interface
uses
{$IFnDEF FPC}
  ShellAPI, MPlayer, Windows,
{$ELSE}
  LCLIntf, LCLType, LMessages,
{$ENDIF}
  Messages, SysUtils, Classes, Graphics, Controls, Forms,
  Dialogs, ExtCtrls, StdCtrls, Menus, Buttons, Grids, ComCtrls,
  ToolWin, IniFiles;

const
  maxdim=6; {rows and columns in board}
  maxvehicles=16; {max nbr of vehicles on any one board}
type
  {TBoardarray is board description vehicle # occupying each row and column}
  TBoardArray=array[1..maxdim,1..maxdim] of byte;
  TDirection=(lefft,right,up,down);
  Tvehicle=class(tobject)    {describes a vehicle}
    Constructor create;
    Destructor destroy; override;
    Procedure assign(source:Tvehicle);
    public
      width,height:integer;
      direction:TDirection;
      row,column:integer;
      size:byte;
      valid:boolean;
      color:TColor;
      colorname:shortstring;
      nbr:integer;
      style:TBrushStyle;
      box:integer;
      vrect:Trect;
      shape:TShapetype;
      image:TBitmap;
      isimage:boolean;
      Procedure setimage(newimage:TBitmap);
      Procedure setcolor(newcolor:integer; newcolorname:string);
      procedure setstyle(newstyle:TBrushstyle);
      procedure setshape(newshape:TShapetype);
      procedure setsize(newsize:integer);
      procedure setdirection(newdirection:TDirection);
      Procedure setlocation(newcolumn, newrow:integer);
    end;

  TSizeParams =record
        box,border:integer;
        boxinner,boxstartleft,boxstarttop:integer;
      end;

  TCase =class(TControl)
     constructor create(Aowner:Tcomponent); override;
     destructor destroy; override;
     Procedure assignCase(source:TCase{TPersistent}); {override;}
     public
      Vehicles:array[1..maxvehicles] of Tvehicle;
      nbrvehicles:integer;
      winningVehicle:integer;
      WinningDirection:TDirection;
      winningpoint:TPoint;
      casename:shortstring;
      createdby:shortstring;
      bestCScore:TPoint; {best computer score} {.x=vehicles moved, .y=blocks moved}
      bestHscore:Tpoint; {best human score}
      bestscoreby:shortstring;
      casesolved:boolean;
      screenparams,printparams:TSizeparams;
      board:tBoardArray;

      Procedure setborderparams(rect:Trect; var params:TSizeParams);
      Function setparams(which:integer; var conflict:integer; checkforsolved:boolean):boolean;
      Procedure resetparams(which:integer);
      Procedure resetboard;

      procedure ImagePrint(printrect:Trect; c:TCanvas; shownums:boolean);
      Function setprintparams(which:integer; params:TSizeparams; var r:Trect):boolean;
    end;

    TCaseList=class(Tlist)
      private
        Constructor Create;
      public
        modified:boolean;
        CaseSetName:shortstring;
        Procedure LoadCasesFromTxt(const filename:string);
        function Find(searchname:string):integer;
      end;

  TForm1 = class(TForm)
    Escapelbl: TLabel;
    ExitLabel: TLabel;
    Label4: TLabel;
    SolveBtn: TButton;
    BoardBox: TPaintBox;
    SoundBtn: TButton;
    ListBox1: TListBox;
    Timer1: TTimer; {delay between moves when autodisplaying solution}
    HintBtn: TButton;
    msgpanel: TPanel;
    MoveCountLbl: TLabel;
    MainMenu1: TMainMenu;
    Application1: TMenuItem;
    Reset1: TMenuItem;
    Hint1: TMenuItem;
    Solve1: TMenuItem;
    N1: TMenuItem;
    N3: TMenuItem;
    Exit1: TMenuItem;
    Options1: TMenuItem;
    HintsOn: TMenuItem;
    SoundOn: TMenuItem;
    About1: TMenuItem;
    NextJamBtn: TButton;
    MediaPlayer1: TMediaPlayer;
    UndoBtn: TButton;
    LevelBox: TComboBox;
    Label1: TLabel;
    BestScoreBox: TListBox;
    SpeedLbl: TLabel;
    SpeedBar: TTrackBar;
    Shownumbers: TMenuItem;
    StaticText1: TStaticText;
    procedure ImagePaint(Sender: TObject);
    procedure BoardBoxMouseMove(Sender: TObject; Shift: TShiftState; X,
                 Y: Integer);
    procedure BoardBoxMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure ListBox1Click(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure SoundBtnClick(Sender: TObject);
    procedure FormPaint(Sender: TObject);
    procedure SolveItClick(Sender: TObject);
    procedure Timer1Timer(Sender: TObject);
    procedure SpeedBarChange(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormResize(Sender: TObject);
    procedure NextJamBtnClick(Sender: TObject);

    procedure BoardBoxMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure HintBtnClick(Sender: TObject);
    procedure playboing;
    procedure About1Click(Sender: TObject);
    procedure HintsOnClick(Sender: TObject);
    procedure SoundOnClick(Sender: TObject);
    procedure RestartthisjamClick(Sender: TObject);
    procedure Formactivate(Sender: TObject);
    procedure UndoBtnClick(Sender: TObject);
    procedure LevelBoxChange(Sender: TObject);
    Procedure makeimage(const v:tvehicle; c:TCanvas; const crect:Trect);
    procedure ShownumbersClick(Sender: TObject);
    procedure StaticText1Click(Sender: TObject);
  public
    { Public declarations }
    cases:TCaseList;
    currentcase:TCase;
    currentcasenbr:integer;
    dragging, blockedUL,blockedDR :Boolean;
    dragvehicle:integer;
    dragdirection:TDirection;
    showcarnbrs:boolean;
    oldpoint:TPoint;
    TrialMoveList:TList;
    movenbr:integer;
    autodist, nextmove:integer;
    exitflag:boolean;
    winner:boolean;

    msgcount:shortint;
    blockmovecount,vehiclemovecount,saveblockmovecount,savevehiclemovecount:integer;
    firstwidth,firstheight:smallint;
    username:string;
    inifile:string;  {name of init file}
    drawit:boolean;  {flag to prevent early drawing on startup}
    winningmoves:TStringlist;
    Function convertScreenToRowCol(Point:Tpoint):TPoint;
    Function convertRowColToScreen(point:Tpoint):Tpoint;
    Procedure LoadCurrentCase(n:integer);
    Procedure dragdraw;
    Procedure MakeWinningMovesList(list:TStringList);
    Procedure ShowSolution;
    Procedure expandmove(move:string;var n:integer; var dir:TDirection; var dist:integer);
    procedure AutoMouseMove(Checkforsolved:boolean);
    function gethead(const n:integer; const board:TBoardArray):tpoint;
    Procedure UpdateMovesLabel;
    Procedure setborderparams;
    function mouseonvehicle(const x,y:integer; var dv:integer):boolean;
    Procedure drawvehicle(n:integer);
    Procedure translatelist(source,dest:TStrings);
    procedure optimizemoves;
    Function movepiece(s:string;var board:TBoardarray):boolean;
    Function validmove(s:string;board:TBoardArray):boolean;
    Procedure DrawBorder(R:Trect;params:TSizeParams; canvas:TCanvas);
    Procedure DoCaseSolved(auto:boolean);
    Procedure makemove(test:string);
    Procedure setlistboxesforcase(var n:integer);
    Procedure setbtns(enable:boolean);
  end;


var
  Form1: TForm1;

implementation
  Uses UAbout, ULogon, UWinnerDlg1A;
  {$IFnDEF FPC}
  {$R *.dfm}
{$ELSE}
  {$R *.lfm}
{$ENDIF}

{******************************************************}
{******************* Local Routines *******************}
{******************************************************}


  Procedure pause(milliseconds:integer);
  var
    t,t2:TDatetime;
    Begin
      t:=time;
      repeat
        application.processmessages;
        t2:=time;
      until (t2-t)*24*3600000> milliseconds;
    end;

{**************************************************************}
{************************ TCaselist ***************************}
{**************************************************************}

  {****************** TCaseList.Create ************************}
   Constructor TCaseList.Create;
   Begin
     inherited;
     modified:=false;
     CaseSetName:='';
   End;

  {******************* TCaseList.LoadCasesFromtext ********************}
  Procedure TCaseList.LoadCasesFromTxt(const filename:string);

      function getword(var w:string):string;
      var
        i:integer;
      Begin
        i:=1;
        result:='';
        If length(w)=0 then exit;
        if w[length(w)]<>',' then w:=w+',';
        while (i<=length(w)) and  (w[i] in [' ',#9]) do inc(i);
        If w[i] =',' {in [' ',#9]} then getword:=''
        else
        Begin
          If i>1 then w:=copy(w,i,length(w)-i+1);
          i:=1;
          while (i<=length(w)) and not (w[i] in [' ',#9,',']) do inc(i);
          getword:=copy(w,1,i-1);
          system.delete(w,1,i);
        End;
      End;

  function  getinteger(var w:string):integer;
  var
    s:string;
    x:integer;
    errcode:integer;
  Begin
    s:=getword(w);
    val(s,x,errcode);
    if errcode=0 then result:=x
    else result:=-999;
  end;

    Function MakeColor(R,G,B:integer):integer;
    Begin
      result:=r or (g shl 8) or (b shl 16);
    end;


    Function RealToStr(Const x:real; Const w,d:integer):string;
      Begin
        str(x:w:d, result);
      End;

    Function ExtractFileRoot(filename:string):String;
    var
      s:string;
      p:integer;
    Begin
      s:=extractfilename(filename);
      p:=pos('.',s);
      if p>0 then s:=copy(s,1,p-1);
      result:=s;
    end;

   var
    f:textfile;
    w:string;
    line:string;
    i,j:integer;
    newcase:Tcase;
    conflict:integer; {# of vehicle which overlaps another}
    validcase:boolean;
  Begin
    clear;
    assignfile(f,filename);
    reset(f);
    casesetname:=ExtractfileRoot(filename);
    newcase:=nil;
    while not eof(f) do
    Begin
      readln(f,line);
      while (not eof(f)) and ((length(line)=0) or (line[1]=';')) do readln(f,line);
      w:=getword(line);
      if length(w)>0 then
      Begin
        if uppercase(w)='CASE' then
        Begin
          newcase:=Tcase.create(nil);
          newcase.casename:=getword(line);
          newcase.createdby:='Original';
          add(newcase);
        end
        else if assigned(newcase) then {add a vehicle}
        with newcase do
        Begin
          inc(nbrvehicles);
          with vehicles[nbrvehicles] do
          Begin
            line:=w+','+line; {put the word back to get as number}
            column:=getinteger(line);
            row:=getinteger(line);
            w:=uppercase(getword(line));
            case w[1] of
              'R': direction:=right;
              'D':direction:=down;
              'L':Direction:=lefft;
              'U':direction:=up;
            end;
            size:=getinteger(line);
            w:=uppercase(getword(line));
            if      w = 'RED' then color:=clred
            else if w= 'LIME'then color:=cllime
            else if w= 'ORANGE'then color:= makecolor(251,158,67)
            else if w= 'PURPLE' then color:=clpurple
            else if w= 'LTPURPLE' then color:= makecolor(201,169,191)
            else if w= 'YELLOW' then  color:=clyellow
            else if w= 'LTYELLOW' then color:= makecolor(245,239,141)
            else if w= 'BLUE' then color:=clblue
            else if w= 'DKBLUE' then color:=makecolor(0,0,160)
            else if w= 'LTBLUE' then color:=makecolor(0,238,225)
            else if w= 'AQUA' then color:= claqua
            else if(w= 'FUCHSIA') or (w='PINK') then color:=clfuchsia
            else if w= 'GRAY' then color:=CLSILVER
            else if w= 'DKGRAY' then color:= makecolor(10,80,55)
            else if w= 'GREEN' then color:=clgreen
            else if w= 'LTGREEN' then color:= makecolor(84,207,142)
            else if w= 'DKGREEN' then color:=makecolor(36,154,27)
            else if w= 'OLIVE' then color:=clOlive
            else if w= 'WHITE' then color:=clwhite
            else if(w= 'TAN') or (w='LTBROWN')  then color:=makecolor(245,206,177)
            else color:= clmaroon;
            colorname:=w;
            if color=clMaroon then colorname:='MAROON';
            style:=bssolid;
            shape:=stroundrect;
            if length(line)>0 then {this line marks winner}
            Begin
              winningvehicle:=nbrvehicles;
              w:=uppercase(getword(line));
              case w[1] of
                'R': winningdirection:=right;
                'D': winningdirection:=down;
                'L': winningDirection:=lefft;
                'U': winningdirection:=up;
                else winningdirection:=right;
              end;
            end;
            nbr:=nbrvehicles;
            image:=nil;
          end;
        end {with newcase}
        else showmessage('Missing case statement, Line:'+#13+line);
      end; {length(w)>0}
    end; {while not eof}
    closefile(f);
    {now check cases and fill in calculated info}
    i:=0;
    while i<=count-1 do
    begin
      with TCase(items[i]) do
      Begin
        resetboard;
        
        validcase:=true;
        j:=1;
        while j<=nbrvehicles do
        with vehicles[j] do
        Begin
          if not setparams(j, conflict,false) then
          Begin
            showmessage('Error in vehicle '+inttostr(j) +' in case '+casename
            +#13+'Overlaps vehicle '+inttostr(conflict));
            delete(j);
            validcase:=false;
          end
          else
          Begin
            if (j=winningvehicle) then
            Begin
              case winningdirection of
               right:
                 Begin
                   winningpoint.x:=maxdim-size+1;
                   winningpoint.y:=row;
                 end;
               lefft:
                 Begin
                   winningpoint.x:=1;
                   winningpoint.y:=row;
                 end;
               up:
                 Begin
                   winningpoint.x:=column;
                   winningpoint.y:=1;
                 end;
               down:
                 Begin
                   winningpoint.x:=column;
                   winningpoint.y:=maxdim-size+1;
                 end;
              end; {case}
            end;
            inc(j);
          end;
        end;
      end;
      If (not validcase) then
       Begin
         Tcase(self[i]).free;
         delete(i);
       end
       else inc(i);
    end;
  end; {LoadCasesFromTxt}


  function TCaseList.Find(searchname:string):integer;
  var
    i:integer;
  begin
    result:=-1;
    i:=0;
    while (i<count) and (result<0) do
    begin
      if TCase(items[i]).casename=searchname then result:=i;
      inc(i);
    end;
  end;



{**************************************************************}
{************************ TCase *******************************}
{**************************************************************}

 {********************* TCase.Create *********************}
constructor TCase.create(Aowner:Tcomponent);
var
  i:integer;
Begin
  inherited create(Aowner);
  nbrvehicles:=0;
  casesolved:=false;
  casename:='';
  createdby:='';
  bestHscore:=point(100,100);
  bestCScore:=point(100,100);
  Bestscoreby:='';
  for i:= 1 to maxvehicles do
  begin
    if not assigned(vehicles[i]) then vehicles[i]:=TVehicle.create;
    with vehicles[i] do
    Begin
      nbr:=i;
      image:=nil;
      valid:=true;
    end;
  end;
end; {Create}

{******************* TCase.AssignCase ***********************}
procedure TCase.assignCase(source:TCase {TPersistent});
{copy source info to this case}
var
  i:integer;
Begin
  nbrvehicles:=tcase(source).nbrvehicles;
  for i:=1 to nbrvehicles do
  begin
    vehicles[i].assign(Tcase(source).vehicles[i]);
    vehicles[i].nbr:=i;
  end;
  winningVehicle:=tcase(source).winningvehicle;
  WinningDirection:=tcase(source).winningdirection;
  winningpoint:=tcase(source).winningpoint;
  casename:=tcase(source).casename;
  board:=tcase(source).board;
  casesolved:=false;
end; {AssignCase}

{******************** TCase.SetParams ********************}
Function tCase.setparams(which:integer; var conflict:integer; checkforsolved:boolean):boolean;
{Verify that vehicle "which" is in a valid new position, also check if new
 position puts the winning vehicle is in the winning position}
{Inputs:   case object and vehicle # with row and column for new position
 Outputs:  updated vehicle positions (left,top, width, height)
           updated board positions
           Conflict: # of vehicle if conflicting with with "which"
           CheckForSolved=true if move gets to winningpoint
}
var
  i:integer;
  l,t,w,h:integer;
Begin
  if not vehicles[which].valid then
  begin
    result:=false;
    exit;
  end;

  result:=true;
  with  vehicles[which], screenparams do
  begin
    l:=boxstartleft + (column-1)*box;
    t:=boxstarttop + (row-1)*box;
    if (direction=lefft) or (direction=right) then
    begin
      w:=size*box-border;
      h:=boxinner;
      for i:=0 to size-1 do
      begin
        if (column+i>maxdim)
        then  begin conflict:=which; result:=false; End
        else if ((board[column+i,row]<>0) and (board[column+i,row]<>which))
        then  Begin conflict:=board[column+i,row]; result:=false;  end;
      end;
      if result
      then for i:=0 to size-1 do board[column+i,row]:=which;
    end
    else
    begin {up/down}
      w:=boxinner;
      h:=size*box-border;
      for i:=0 to size-1 do
      if (row+i>maxdim) then Begin conflict:=0; result:=false; end
      else
      if ((row+i<=maxdim) and (board[column,row+i]<>0) and (board[column,row+i]<>which))
      then begin conflict:=board[column,row+i]; result:=false; end;
      if result
      then for i:=0 to size-1 do board[column,row+i]:=which;
    end;
    If result then with vehicles[which] do
    begin
      vrect:=rect(l,t,l+w,t+h);
      width:=w;
      height:=h;
      if checkforsolved and (which=winningvehicle) and (row=winningpoint.y) and (column=winningpoint.x)
      then casesolved:=true;
    end;
  end;
end; {Setparams}



{******************** TCase.ReSetParams ********************}
Procedure tcase.resetparams(which:integer);
{Clear out board positions before deleteing a vehicle}
var
  i:integer;
Begin
  with  vehicles[which] do
  if valid then 
  begin
    case direction of
      lefft,right: for i:=0 to size-1 do  board[column+i,row]:=0;
      up,down:   for i:=0 to size-1 do  board[column,row+i]:=0;
    end;
  end;
end;

{******************** TCase.SetprintParams ********************}
Function tCase.setprintparams(which:integer; params:TSizeparams; var r:Trect):boolean;
{make a vehicle image for printing}
var
  i:integer;
  l,t,w,h:integer;
Begin
  result:=false;
  if not vehicles[which].valid then exit;
  result:=true;
  with  vehicles[which], params do
  begin
    l:=boxstartleft + (column-1)*box;
    t:=boxstarttop + (row-1)*box;
    if (direction=lefft) or (direction=right) then
    Begin
      w:=size*box-border;
      h:=boxinner;
      for i:=0 to size-1 do
      Begin
        if (column+i>maxdim)
        then  begin result:=false; End;
      end;
      if result then
         for i:=0 to size-1 do board[column+i,row]:=which;
    end
    else
    Begin {up/down}
      w:=boxinner;
      h:=size*box-border;
      for i:=0 to size-1 do
      if (row+i>maxdim) then Begin result:=false; end
      else if ((row+i<=maxdim) and (board[column,row+i]<>0) and (board[column,row+i]<>which))
       then begin result:=false; end;
      if result then
      for i:=0 to size-1 do board[column,row+i]:=which;
    end;
     If result then with vehicles[which] do
     Begin
       r:=rect(l,t,l+w,t+h);
     end;
  end;
end; {Setprintparams}


{********************* TCase.ImagePrint ********************}
procedure TCase.ImagePrint(printrect:Trect; c:TCanvas; shownums:boolean);
{ Print the board image}
  var
  i,j, PL,Pt:integer;
  printparams:TSizeparams;
  r, saverect:TRect;
  sz:TSize;
  s:string;
begin
  {set top/left parameters}
   setborderparams(printrect,printparams);
  {scale everything to printrect rectangle size}
  pL:=printrect.left; pt:=printrect.top;
  for i:=0 to maxdim-1 do
  with c, printparams do
  Begin
    brush.color:=clgray;
    r.left:=pL+boxstartleft +i*box;
    r.right:=r.left+boxinner;
    for j:=0 to maxdim-1 do
    if board[i+1,j+1]=0 then
    Begin
      r.top:=pt+boxstarttop +j*box;
      r.bottom:=r.top+boxinner;
      c.fillrect(r);
    end;
  end;
  {now print vehicles}

  for  i:= 1 to nbrvehicles do
  with vehicles[i] do
  if valid then
  begin
    setprintparams(i,printparams,r); {get the rectangle for each vehicle}
    if not assigned(image) then
    Begin
      image:=TBitMap.Create;
      image.width:=r.right-r.left;
      image.height:=r.bottom-r.Top;
      saverect:=vrect;
      vrect:=r;
      form1.makeimage(vehicles[i],image.canvas,rect(0,0,image.width,image.height));
      vrect:=saverect;
    end;
    c.stretchdraw(rect(r.left+pl,r.top+pt,r.right+pL,r.bottom+pt),image);
    if shownums then
    begin
      s:=inttostr(i);
      sz:=c.textextent(s);
      c.brush.color:=clwhite;
      c.textout(PL+(r.left+r.right-sz.cx) div 2, PT+(r.top+r.bottom-sz.cy) div 2,s);
    end;
  end;
  {print border}
   {save screen location of exit label since we're going to be changing it}
   with form1.exitlabel do saverect:=rect(left,top,height,width);
   form1.DrawBorder(printrect, printparams, c);

   with form1.exitlabel do
   Begin
     c.fillrect(boundsrect);
     c.Font.color:= clred;
     c.font.size:=font.Size;
     sz:=c.textextent(caption);
     c.textout(left+(width-sz.cx) div 2,top+(height-sz.cy) div 2, caption);
     left:=saverect.left;
     top:=saverect.top;
     width:=saverect.right;
     height:=saverect.bottom;
     c.font.color:=clblack;
   end;

end; {ImagePrint}

{******************** TCase.ResetBoard *******************}
Procedure TCase.resetboard;
  var
    i,j:integer;
  Begin
   for i:=1 to maxdim do for j:=1 to maxdim do board[i,j]:=0;
   for i:=1 to nbrvehicles do
   if assigned(vehicles[i].image)
   then freeandnil(vehicles[i].image);
   casesolved:=false;
  end;

{******************** TCase.SetBorderParams ********************}
{Set box and border sizes for a given rectangle}
Procedure tCase.setborderparams(rect:Trect; var params:TSizeParams);
Begin
  with params do
  Begin
    box:=(rect.right -rect.left) div maxdim;
    border:=(rect.right-rect.left) div 100; {border space between boxes = 1%}
    boxinner:=box-border;
    boxstartleft:={rect.left+}1+ border;
    boxstarttop:={rect.top+}1+border;
  end;
end;  {SetBorderParams}



{********************** TCase.Destroy *************************}
destructor TCase.destroy;
var
  i:integer;
begin
  {winningmoves.free; }
  for i:=1 to maxvehicles do
  with vehicles[i] do free; {if assigned(image) then image.free;}
  inherited destroy;
end; {Destroy}

{**************************************************************}
{************************ TVehicle *******************************}
{**************************************************************}

{******************** TVehicle.Create ***************}
Constructor TVehicle.create;
Begin
  inherited;
  color:=clblue;
  colorname:='Blue';
  shape:=strectangle;
  style:=bssolid;
  row:=0;
  column:=0;
  direction:=lefft;
  size:=2;
  box:=100;
end;


{***************** TVehicle.SetImage ***********}
Procedure TVehicle.setimage(newimage:TBitmap);
  Begin
    image.assign(newimage);
    isimage:=true;
  end;

{*************** TVehicle.SetColor ***************}
Procedure TVehicle.setcolor(newcolor:integer; newcolorname:string);
  begin
    isimage:=false;
    color:=newcolor;
    colorname:=newcolorname;
  end;

{******************* TVehicle.SetStyle ************}
procedure TVehicle.setstyle(newstyle:TBrushstyle);
  Begin
    isimage:=false;
    style:=newstyle;
  end;

{**************** TVehicle.setShape **************}
procedure TVehicle.setshape(newshape:TShapetype);
  begin
    isimage:=false;
    shape:=newshape;
  end;

{****************** TVehicle.SetDirection *************}
Procedure TVehicle.setdirection(newdirection:TDirection);
  Begin  direction:=newdirection;   end;

{************** TVehicle.Setsize ****************}
Procedure TVehicle.Setsize(newsize:integer);
  begin  size:=newsize;  end;

{************** TVehicle.SetLocation ****************}
Procedure TVehicle.setlocation(newcolumn, newrow:integer);
  begin
    column:=newcolumn;
    row:=newrow;
  end;

{************** TVehicle.Destroy ****************}
Destructor TVehicle.destroy;
Begin
  if assigned(image) then image.free;
  inherited;
End;

{************** TVehicle.Assign ****************}
Procedure TVehicle.assign(source:TVehicle);
  Begin
    inherited;
    color:=tvehicle(source).color;
    colorname:=tvehicle(source).colorname;
    style:=tvehicle(source).style;
    column:=tvehicle(source).column;
    row:=tvehicle(source).row;
    size:=tvehicle(source).size;
    shape:=tvehicle(source).shape;
    direction:=tvehicle(source).direction;
    image:=tvehicle(source).image;
    valid:=TVehicle(source).valid;
  end;

{**************************************************************}
{***************************** TForm **************************}
{**************************************************************}


{*********************** TForm1.MakeImage ************************}
Procedure TForm1.makeimage(const v:TVehicle; c:TCanvas; const crect:Trect);
var
  x:integer;
  s:string;
  sz:TSize;
  begin
    with c ,v do
    Begin
      brush.color:=cldkgray;
      fillrect(crect);
      brush.color:=color;

      case shape of
        strectangle: with crect do rectangle(left,top,right,bottom);
        stroundrect:
          with crect do
          begin
            if (right-left)<(bottom-top)
            then x:= (right-left) div 2
            else x:=(bottom-top) div 2;
            roundrect(left,top,right,bottom,x,x);
          end;
        stellipse: with crect do ellipse(left,top,right,bottom);
      end;
      if shape<>stcircle then
      begin
        {fill it in}
        brush.style:=bssolid;
        with crect do
        floodfill((left+right) div 2, top+1, pen.color,fsborder);
        {draw patterns if necessary}
        brush.style:=style;
        if style<>bsSolid then
        begin
          brush.color:=brush.color xor $ffffff;
          case shape of
            strectangle: with crect do rectangle(left,top,right,bottom);
            stroundrect: with crect do roundrect(left,top,right,bottom,20,20);
            stellipse: with crect do ellipse(left,top,right,bottom);
          end;
        end;
      end;
    end;
    if showcarnbrs then
    begin
      s:=inttostr(v.nbr);
      sz:=c.textextent(s);
      c.brush.color:=clwhite;
      c.textout((crect.left+crect.right-sz.cx) div 2, (crect.top+crect.bottom-sz.cy) div 2,s);
    end;
  end; {makeimage}


{******************* TForm1.PlayBoing ***********************}
procedure TForm1.playboing;
    Begin
      if Soundon.checked then
      with mediaplayer1 do
      Begin
        filename:=extractfilepath(application.exename)+'carboing.wav';
        try   open;    finally wait:=true; play;  end;
        filename:=extractfilepath(application.exename)+'carmove.wav';
        try   open;    finally  end;
      end;
    end;


{********************** TForm1.UpdateMovesLabel ********************}
Procedure TForm1.UpdateMovesLabel;
begin
  inc(vehiclemovecount);
  movecountlbl.caption:='  Vehicle moves: '+inttostr(vehiclemovecount)
                    +'  Blocks traveled: ' +inttostr(blockmovecount)+'  ';
end;



{********************* TForm1.DrawVehicle *********************}
Procedure TForm1.drawvehicle(n:integer);
  Begin;
    with currentcase,vehicles[n] do
    if valid then 
    Begin
      {draw the shape}
      if not assigned(image) then
      Begin
        image:=TBitMap.Create;
        image.width:=width;
        image.height:=height;
        makeimage(vehicles[n],image.canvas,rect(0,0,image.width,image.height));
      end;
      boardbox.canvas.stretchdraw(vrect,image)
    end;
  end;

{********************** TForm1.ImagePaint ********************}
procedure TForm1.ImagePaint(Sender: TObject);
{ Repaints the board image}
  var
  i,j:integer;
  rect:Trect;
begin
  if not drawit then exit;
  //DrawBorder(BoardBox.BoundsRect,currentcase.screenparams,canvas);
  if assigned(currentcase) and currentcase.casesolved then exit;
  for i:=0 to maxdim-1 do
  with boardbox.canvas, currentcase, screenparams do
  Begin
    brush.color:=clgray;
    rect.left:=boxstartleft +i*box;
    rect.right:=rect.left+boxinner;
    for j:=0 to maxdim-1 do
    if board[i+1,j+1]=0 then
    Begin
      rect.top:=boxstarttop +j*box;
      rect.bottom:=rect.top+boxinner;
      fillrect(rect);
    end;
  end;
  {now draw vehicles}
  for  i:= 1 to currentcase.nbrvehicles do  drawvehicle(i);
  exitlabel.bringtofront;
end;


{********************************TForm1.DragDraw ************************}
Procedure TForm1.dragdraw;
var
  r:Trect;
Begin
  with currentcase  do
  Begin
    {If SoundOn.Checked then mediaplayer1.play;}
    inc(blockmovecount);
  end;
  with  boardbox, currentcase, vehicles[dragvehicle], screenparams, canvas do
  Begin
    {draw vehicle in new location}
    brush.color:=color;
    brush.style:=style;
    drawvehicle(dragvehicle);
    { now erase artifacts from old location}
    brush.style:=bssolid;
    brush.color:=clgray;
    case dragdirection of
    lefft:
        if column+size<=maxdim then
        Begin
          r:=rect(vrect.right+border,vrect.top,vrect.right+box,vrect.bottom);
          fillrect (r);
          brush.color:=clbtnface;
          r:=rect(vrect.right,vrect.top,vrect.right+border,vrect.bottom);
          fillrect(r);
        end;
    right:
        If column>1 then
        Begin
          r:=rect(vrect.left-box,vrect.top,vrect.left-border,vrect.bottom);
          canvas.fillrect(r);
          brush.color:=clbtnface;
          r:=rect(vrect.left-border,vrect.top,vrect.left,vrect.bottom);
          fillrect(r);
        end;
    up:
        if row+size<=maxdim then
        Begin
          r:=rect(vrect.left,vrect.bottom+border,vrect.right,vrect.bottom+box);
          canvas.fillrect(r);
          brush.color:=clbtnface;
          r:=rect(vrect.left,vrect.bottom,vrect.right,vrect.bottom+border);
          fillrect(r);
        end;
    down:
        if row>1 then
        Begin
          r:=rect(vrect.left,vrect.top-box,vrect.right,vrect.top-border);
          fillrect(r);
          brush.color:=clbtnface;
          r:=rect(vrect.left,vrect.top-border,vrect.right,vrect.top);
          fillrect(r);
        end;
    end;
  end;
end;

{******************** TForm1.Setborderparams *********************}
Procedure TForm1.setborderparams;
var
  r:TRect;
Begin
  with BoardBox do If height<width then width:=height  else height:=width;
  with BoardBox do r:=rect(0{left},0{top},{left+}width,{top+}height);
  currentcase.setborderparams(r,currentcase.screenparams);
  (*
  with pleasewaitpanel do
  Begin
    left:=BoardBox.Left;
    top:=BoardBox.top;
    width:=BoardBox.width;
    height:=BoardBox.height;
  end;
  *)
  (*
  with currentcase, screenparams do
  Begin
    exitlabel.width:=box-border;
    exitlabel.height:=box-border;
  end;
  *)
end;


{****************** TForm1.ConvertScreenToRowCol *******************}
Function TForm1.convertScreenToRowCol(point:Tpoint):Tpoint;
Begin
  result.y:=(point.y) div currentcase.screenparams.box +1;
  result.x:=(point.x) div currentcase.screenparams.box +1;
  if (result.x<0) or (result.x>maxdim)
     or (result.y<0) or (result.y>maxdim)
  then
  Begin
    result.x:=0;
    result.y:=0;
  end;
End;

{******************* TForm1.MouseOnVehicle *****************}
function TForm1.mouseonvehicle(const x,y:integer; var dv:integer):boolean;
var
  i:integer;
  onvehicle:boolean;
  v:trect;
  xx,yy:integer;
Begin
  i:=0;
  onvehicle:=false;
  with currentcase do
  while (i<nbrvehicles) and (not onvehicle) do
  Begin
    inc(i);
    with vehicles[i],vrect do
    if valid then
    Begin
      v:=vehicles[i].vrect;
      xx:=x;
      yy:=y;
      if (xx>=left) and (xx<right) and (yy>=top) and (yy<bottom) then
      Begin
        dv:=i;
        onvehicle:=true;
      end;
    end;
  end;
  result:=onvehicle;
end;

{****************** TForm1.ConvertRowColToScreen *******************}
Function TForm1.convertRowColToScreen(point:Tpoint):Tpoint;
var  p:Tpoint;
Begin
  p:=point;
  result.y:=(p.y-1) *currentcase.screenparams.box;
  result.x:=(p.x-1) * currentcase.screenparams.box;
End;

{*********************** TForm1.PaintBox1MouseDown ***********************}
procedure TForm1.BoardBoxMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);

    Function canadd(p:tpoint;newdirection:TDirection;newsize:integer):boolean;
    var
      conflict:integer;
      templist:TStringlist;
    Begin
      result:=true;
      with currentcase do
      Begin
        inc(nbrvehicles);
        with vehicles[nbrvehicles] do
        begin
          column:=p.x;
          row:=p.y;
          size:=newsize;
          direction:=newdirection;
          if setparams(nbrvehicles, conflict, false) then
          Begin
            templist:=tstringlist.create;
            Makewinningmoveslist(templist);
            if templist.count=0 then result:=false;
            resetparams(nbrvehicles);
            dec(nbrvehicles);      {???}
            templist.free;
          end
          else result:=false;
        end;
      end;
    end; {canadd}
var
  p:TPoint;
  pv:TPoint;

begin
  {mbleft}
  if (button=mbleft) and mouseonvehicle(x,y,dragvehicle) then
  begin
    dragging:=true;
    blockedUL:=false;
    BlockedDR:=false;
    screen.cursor:=crdrag;
    pv:=currentcase.Vehicles[dragvehicle].vrect.topleft;
    p:=boardbox.clienttoscreen(point(pv.x,pv.y));
    with currentcase.vehicles[dragvehicle] do
    begin
      oldpoint.x:=pv.x+width div 2;
      oldpoint.y:=pv.y+height div 2;
      setcursorpos(p.x+width div 2,p.y +height div 2);
    end;
    saveblockmovecount:=blockmovecount; {to check later to see if vehicle moved}
    savevehiclemovecount:=vehiclemovecount;
    undobtn.enabled:=true;
    if SoundOn.Checked then
    with mediaplayer1 do
    Begin
      filename:=extractfilepath(application.exename)+'carmove.wav';
      try   open; wait:=false;   finally      end;
    end;
  end;
end;

{************************* TForm1.FormMouseMove ********************}
procedure TForm1.BoardBoxMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);

    Function reversemove(move:string):boolean;
    var
      test:string;
    Begin
      test:=move;
      case move[2] of
        'L': test[2]:='R';
        'R': test[2]:='L';
        'U': test[2]:='D';
        'D': test[2]:='U';
      end;
      with winningmoves do
      if (count>0) and (strings[count-1]=test) then result:=true
      else result:=false;
    end;


    procedure playboing;
    Begin
      if SoundOn.Checked then
      with mediaplayer1  do
      Begin
        filename:=extractfilepath(application.exename)+'carboing.wav';
        try   open;    finally wait:=true; play;  end;
        play;
        filename:=extractfilepath(application.exename)+'carmove.wav';
        try   open;    finally  end;
      end;
    end;


  const
    preda=ord(pred('A'));
  var
    i,c,save, conflict:integer;
    rcpoint, topleftpoint :TPoint;
    move:string;

begin {FormMouseMove}
  if timer1.enabled then exit; {we're autosolving a case, ignore mouse movements}
  if dragging and ((abs(x-oldpoint.x)>5) or (abs(y-oldpoint.y)>5)) then
  with currentcase  do
  Begin
    with vehicles[dragvehicle] do
    Begin
      if dragvehicle<>nbr then showmessage('Mouse Move logic error - email Grandpa');
      oldpoint.x:=x;
      oldpoint.y:=y;
      {cursor is middle of vehicle - get topleft from there}
      topleftpoint:=point(x-width div 2, y-height div 2);
      rcpoint:=convertscreentoRowCol(topleftpoint);
      if (rcpoint.x>0) and  (direction in [lefft,right])
      then
      Begin
        i:=rcpoint.x;
        if (i>0) and (i<>column) then
        if (i  < column) then {moving left}
        Begin
          save:=column;
          column:=i;
          if (not blockedUL) and  setparams(dragvehicle, conflict, true)
          then
          for c:= save-1 downto i do
          Begin
            column:=c;
            board[column+size,row]:=0;
            blockedDR:=false; {in case we were blocked right, now we're not}
            dragdirection:=lefft;
            dragdraw;
            move:=char(preda+ord(dragvehicle))+'L1';
            if reversemove(move)
            then
            Begin
              dec(blockmovecount,2);
              winningmoves.delete(winningmoves.count-1);
            end
            else winningmoves.add(move);
          end
          else
          Begin
            blockedUL:=true;
            column:=save;
            playboing;
          end;
        end
        else
        Begin   {moving right}
          save:=column;
          column:=i;
          if (not blockedDR)
          and  setparams(dragvehicle, conflict, true)
          then
          for c:=save+1 to i do  {in case we moved multiple colums}
          Begin
            column:=c;
            board[column-1,row]:=0;
            blockedUL:=false; {in case we were blocked left, now we're not}
            dragdirection:=right;
            dragdraw;
            move:=char(preda+ord(dragvehicle))+'R1';
            if reversemove(move)
            then
            Begin
              dec(blockmovecount,2);
              winningmoves.delete(winningmoves.count-1);
            end
            else winningmoves.add(move);
           
          end
          else
          Begin
            blockedDR:=true;
            column:=save;
            playboing;
          end;
        end
      End
      else
      if (rcpoint.y>0) and (direction in [up,down]) then
      begin
        i:=rcpoint.y;
        if (i <> row) then
        if i< row then {moving up}
        Begin
          save:=row;
          row:=i;
          if (not blockedUL) and setparams(dragvehicle, conflict,true)
          then
          for c:= save-1 downto i do
          Begin
            row:=c;
            board[column,row+size]:=0;
            blockedDR:=false; {in case we were blocked down, now we're not}
            dragdirection:=up;
            dragdraw;
            move:=char(preda+ord(dragvehicle))+'U1';
            if reversemove(move)
            then
            Begin
              dec(blockmovecount,2);
              winningmoves.delete(winningmoves.count-1);
            end
            else winningmoves.add(move);
          end
          else
          begin
            blockedUL:=true;
            row:=save;
            playboing;
          end;
        End
        else
        Begin {moving down}
          save:=row;
          row:=i;
          if (not blockedDR) and  setparams(dragvehicle, conflict, true)
          then
          for c:= save+1 to i do
          Begin
            row:=c;
            board[column,row-1]:=0;
            blockedUL:=false; {in case we were blocked up, now we're not}
            dragdirection:=down;
            dragdraw;
            move:=char(preda+ord(dragvehicle))+'D1';
            if reversemove(move)
            then
            Begin
              dec(blockmovecount,2);
              winningmoves.delete(winningmoves.count-1);
            end
            else winningmoves.add(move);
          end
          else
          begin
            blockedDR:=true;
            row:=save;
            playboing;
          end;
        End;
      End;
      if (rcpoint.x=0) or (rcpoint.y=0)
      then playboing;
    end;

    if currentcase.casesolved then docasesolved(false)
    else if SoundOn.Checked then mediaplayer1.play;
  end;
end;  {formMouseMove}


{********************** TForm1.FormMouseUp **********************}
procedure TForm1.BoardBoxMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if (button=mbleft) and dragging then
  Begin
    dragging:=false;
    blockedUL:=false;
    blockedDR:=false;
    screen.cursor:=crDefault;
    if blockmovecount=saveblockmovecount
    then vehiclemovecount:=savevehiclemovecount-1;{Update moves label will add 1}
    If not currentcase.casesolved then UpdateMovesLabel;
     with currentcase, vehicles[dragvehicle] do
     begin
      {if position=winning position and dragged block is not the winning car,
       then assume that this is one that is simply to be removed}
        if (dragvehicle<>winningvehicle) and (column=winningpoint.x) and (row=winningpoint.y)
        and (direction=winningdirection)
        then
        begin
          resetparams(dragvehicle);
          valid:=false;
          boardbox.invalidate;
        end;
    end;
    if blockmovecount>0 then undobtn.enabled:=true;
    {listbox2.items.add(inttostr(allocmemsize));   }
  end;
end; {FormMouseUp}

{*********************** TForm1.TranslateList *****************}
Procedure TForm1.translatelist(source,dest:TStrings);
{Make moveslist readable mere mortals}
const
  preda=ord(pred('A'));
var
  i,n:integer;
  s,s1,s2:string;
Begin
  dest.clear;
  for i:= 0 to source.count-1 do
  Begin
    s:=source[i];
    n:=ord(s[1])-preda;

    s1:='Vehicle ';
    if n<10 then s1:=s1+' '; {to keep printed length constant?}
    s1:=s1+inttostr(n);
    case s[2] of
    'L': s2:=' Left ';
    'R': s2:=' Right ';
    'U': s2:=' Up ';
    'D': s2:=' Down ';
    end;
    s:=s1+s2+s[3];
    dest.add(s);
  end;
end;

{******************* TForm1.DoCaseSolved ***********}
Procedure TForm1.DoCaseSolved(auto:boolean);

      Procedure optimizemoves1;
      const
        preda=ord(pred('A'));
      var
        i:integer;
        prevs,s:string;
      Begin
        i:=1;
        prevs:={currentcase.}winningmoves[0];
        while i<={currentcase.}winningmoves.count-1 do
        with currentcase do
        begin
          s:=winningmoves[i];
          if (s[1]=prevs[1]) and (s[2]=prevs[2]) then
          begin
            prevs[3]:=char(ord(prevs[3])+ord(s[3])-ord('0'));
            winningmoves[i-1]:=prevs;
            winningmoves.delete(i);
          end
          else
          Begin
            prevs:=s;
            inc(i);
          end;
        end;
      end;

    var
      msg1,msg2:string;

    Begin {DocaseSolved}
      UpdateMovesLabel;
      if auto then
      Begin
        timer1.enabled:=false; {stop automoving if it's happening}
        pause(2*timer1.interval); {pause to show last move}
      end
      else OptimizeMoves1; {optimize move list if manually solved}

      with Tcase(cases[currentcasenbr-1]) do
      Begin
        if (auto and (
             (bestCscore.y>blockmovecount) or (
               (bestCscore.y=blockmovecount) and (bestCscore.x>vehiclemovecount)
                                               )
                     )
            )
        or ((auto=false) and  (
             (bestHscore.y>blockmovecount) or (
               (bestHscore.y=blockmovecount) and (bestHscore.x>vehiclemovecount)
                                              )
                               )
           )

        then
        Begin
          if auto then
          Begin
            bestCscore.x:=vehiclemovecount;
            bestCscore.y:=blockmovecount;
          end
          else
          Begin
            bestHscore.x:=vehiclemovecount;
            bestHscore.y:=blockmovecount;
            BestScoreBy:=username;
          End;
          if bestCscore.x=100 then msg1:=' Low computer score: Not solved'
          else msg1:='Low computer score: '+inttostr(BestCscore.x)+' moves '
                     +inttostr(BestCScore.y)+ ' blocks';
          If bestHScore.x=100 then msg2:=' Low human score: Not solved'
          else msg2:='Low human score: '+inttostr(BestHScore.x)
                    +' moves '+inttostr(BestHScore.y)+' blocks ('+BestScoreBy+')';
          BestScorebox.items[0]:=msg1;
          BestscoreBox.items[1]:=msg2;
        end;
      end;
      if SoundOn.Checked then
      with mediaplayer1 do
      Begin
        filename:=extractfilepath(application.exename)+'caseend1.wav';
        try  open;   finally  wait:=true; play;   end;
        filename:=extractfilepath(application.exename)+'caseend2.wav';
        try  open;  finally   play;   end;
      end;
      screen.cursor:=crDefault;
      self.dragging:=false;
      SpeedBar.visible:=false;   SpeedLbl.visible:=false;
      if auto then
      winnerdlg.caption:=currentcase.Casename +' solved by a very smart computer program'
      else winnerdlg.caption:=currentcase.Casename +' solved by '+ username;
      winnerdlg.nextjam:=currentcasenbr;
      translatelist({currentcase.}winningmoves,winnerdlg.ListBox1.items);
      WinnerDlg.showmodal;
      loadcurrentcase(winnerdlg.nextjam);
    end;


{********************** TForm1.Automousemove *******************}
procedure TForm1.AutoMouseMove(Checkforsolved:boolean);
{Move 1 square in current dragdirection}

      procedure playboing;
      Begin
        {disable timer to prevent further move attempts}
        timer1.enabled:=false;
        showmessage('Something''s wrong in AutoMove, email Grandpa');
        exitflag:=true;
      end;

var
  conflict:integer;

begin {AutoMouseMove}
  with currentcase, vehicles[dragvehicle] do
  Begin
    case
      dragdirection of
      lefft:  dec(column);
      right:  inc(column);
      up:  dec(row);
      down: inc(row);
    end;
    conflict:=0;
    if setparams(dragvehicle, conflict, checkforsolved)
    then
    begin
      case dragdirection of
        lefft: board[column+size,row]:=0;
        right: board[column-1,row]:=0;
        up:  board[column,row+size]:=0;
        down:  board[column,row-1]:=0;
      end;
      dragdraw;
      {if position=winning position and dragged block is not the winning car,
       then assume that this is one that is simply to be removed}
       {Note this code only works for right exits, need more complex test
        if other directions were to be implemented}
       with currentcase do
       if (dragvehicle<>winningvehicle) and (column=winningpoint.x)
         and (dragdirection=right) and (row=winningpoint.y)
       then
       begin
         resetparams(dragvehicle);
         valid:=false;
         imagepaint(self);
       end;
    end
    else begin playboing; exit; end;
    if casesolved then DoCaseSolved(true);
    {else if SoundOn.Checked then mediaplayer1.play;}
  end;
end; {AutoMouseMove}




{********************* TForm1.Listbox1Click *****************}
procedure TForm1.ListBox1Click(Sender: TObject);
{user selected a new case}
var
  s:string;
  errcode:integer;
begin
  with levelbox do
  Begin
    with TStringlist(items.objects[itemindex]) do
    Begin {extract the case number from the beginning of the levelbox list entry}
      s:=strings[listbox1.itemindex];
      val(copy(s,1,2),currentcasenbr,errcode);
    end;
  end;
  LoadCurrentcase(currentcasenbr);
end;

{***************** TForm1.SetListBoxesForCase ************}
Procedure tform1.setlistboxesforcase(var n:integer);
{make sure displayed list boxes match currently displayed case}
var
  i,test,errcode:integer;
  s:string;
Begin
  if n>cases.count then n:=1;
  if listbox1.itemindex<0 then listbox1.itemindex:=0;
  {check if current item = n first}
  with TStringlist(levelbox.items.objects[levelbox.itemindex]) do
  Begin
    s:=strings[listbox1.itemindex];
    val(copy(s,1,2),test,errcode);
  end;
  if test=n then exit;
  {next most likely is next entry - check it}
  while test<>n do
  Begin
    if listbox1.itemindex<listbox1.items.count-1
    then listbox1.itemindex:=listbox1.itemindex+1
    else
    Begin
      {go to next level}
      if levelbox.itemindex<levelbox.items.count-1
      then levelbox.itemindex:=levelbox.itemindex+1
      else levelbox.itemindex:=0;
      listbox1.clear;
      with TStringlist(levelbox.items.objects[levelbox.itemindex]) do
      for i:=0 to count-1 do
      Begin
        s:=strings[i];
        system.delete(s,1,2);
        listbox1.items.add(s);
      end;
      listbox1.itemindex:=0;
    end;
    with TStringlist(levelbox.items.objects[levelbox.itemindex]) do
    Begin
      s:=strings[listbox1.itemindex];
      val(copy(s,1,2),test,errcode);
    end;
  end;
end;


{*********************** TForm1.LoadCurrentCase *****************}
Procedure TForm1.LoadCurrentCase(n:integer);
var
  i:integer;
  conflict:integer;
  msg1,msg2:string;
Begin
  currentcase.resetboard;
  winningmoves.clear;
  SetListBoxesForCase(n);
  currentcasenbr:=n;
  currentcase.assignCase(Cases[n-1]);
  with tcase(cases[n-1]) do
  Begin
    if bestCscore.x=100 then msg1:='Low computer score: Not solved'
    else msg1:='Low computer score: '+inttostr(BestCscore.x)+' vehicles '
                +inttostr(BestCScore.y)+ ' blocks';
    If bestHScore.x=100 then msg2:='Low human score: Not solved'
    else msg2:='Low human score: '+inttostr(BestHScore.x)
    +' vehicles '+inttostr(BestHScore.y)+' blocks ('+BestScoreBy+')';
    BestScoreBox.items[0]:=msg1;
    BestScoreBox.items[1]:=msg2;
  end;

  setborderparams;
  for i:=1 to currentcase.nbrvehicles do currentcase.setparams(i, conflict, false);
  if SoundOn.Checked then
  with mediaplayer1 do
  Begin
    filename:=extractfilepath(application.exename)+'carhorns.wav';
    try  open;   finally  play;   end;
  end;
  blockmovecount:=0;
  vehiclemovecount:=-1;
  undobtn.enabled:=false;
  UpdateMovesLabel; {show initial values}
  invalidate;
End;


{******************** TForm1.FormClose *************************}
procedure TForm1.FormClose(Sender: TObject; var Action: TCloseAction);
var
  ini:TInifile;
  i:integer;
begin
  ini:=TIniFile.create(inifile);
  for i:=0 to cases.count-1 do
  with ini, tcase(cases[i]) do
  begin
    writeinteger(casename, 'ComputerScoreVehicles', bestCScore.x);
    writeinteger(casename, 'ComputerScoreBlocks', bestCScore.y);
    writeinteger(casename, 'BestHumanScoreVehicles', bestHScore.x);
    writeinteger(casename, 'BestHumanScoreBlocks', bestHScore.y);
    writestring(casename,'BestScoreBy',bestscoreby);
  end;
  ini.free;
  if SoundOn.Checked then
  try
    with mediaplayer1 do
    Begin
      filename:=extractfilepath(application.exename)+'progend.wav';
      try  open;   finally wait:=true;  play;   end;
    end;
    mediaplayer1.close;
    finally
      action:=cafree;
   end;
end;

{************************** TForm1.SoundBtnClick ***********************}
procedure TForm1.SoundBtnClick(Sender: TObject);
begin
  SoundOn.Checked:=not SoundOn.Checked;
  If SoundOn.Checked then soundbtn.caption:='Those stupid sounds are bugging me!'
  else
  Begin
    soundbtn.caption:='Let''s make some noise!';
    mediaplayer1.close;
  end;
end;

{*************************** TForm1.DrawBorder **************}
Procedure TForm1.DrawBorder(R:Trect;params:TSizeParams; canvas:TCanvas);
  var
    b2:integer;
    w,h:integer;
    outcorn,incorn:array[1..5] of tpoint;
  Begin
    {draw polygons to make an outside border for image1}
    h:=r.bottom-r.top;
    w:=r.right-r.left;
    b2:=2*params.border+2;
    outcorn[1].x:=r.left-b2+1;
    outcorn[1].y:=r.top-b2+1;
    outcorn[2]:=outcorn[1];
    with outcorn[2] do y:=y+2*b2+h;
    outcorn[3]:=outcorn[2];
    with outcorn[3] do x:=x+2*b2+w;
    outcorn[4].x:=outcorn[3].x;
    outcorn[4].y:=outcorn[1].y;
    outcorn[5]:=outcorn[1];
    incorn[1].x:=outcorn[1].x+4;
    incorn[1].y:=outcorn[1].y+4;
    incorn[2]:=incorn[1];
    incorn[2].y:=outcorn[2].y-4;
    incorn[3]:=incorn[2];
    incorn[3].x:=outcorn[3].x-4;
    incorn[4].x:=incorn[3].x;
    incorn[4].y:=incorn[1].y;
    incorn[5]:=incorn[1];
    canvas.Polyline(incorn);
    canvas.Polyline(outcorn);
    update;
    If currentcasenbr>0 then
    with canvas, boardbox, currentcase, params do
    Begin
      {Place the exit label}
      exitlabel.width:=box-border;
      exitlabel.height:=box-border;
      case winningdirection of
        right:
        Begin
          exitlabel.top:=r.top+(winningpoint.y-1)*box+boxstartTop;
          exitlabel.left:=r.left+maxdim*box;
        end;
        lefft:
        begin
          exitlabel.top:=r.top+(winningpoint.y-1)*box+boxstartTop;
          exitlabel.left:=r.left-exitlabel.width+boxstartleft;
        end;
        up:
        begin
          exitlabel.top:=r.top-exitlabel.height+boxstarttop;
          exitlabel.left:=r.left+(winningpoint.x-1)*box + boxstartleft;
        end;
        down:
        begin
          exitlabel.top:=incorn[2].y-2*border+1;
          exitlabel.left:=incorn[2].x+(winningpoint.x-1)*(box+border) +border+2;
        end;
      end; {case}
    end;
    exitlabel.visible:=true;
    //exitlabel.invalidate;
  end;

{************************** TForm1.FormPaint **********************}
procedure TForm1.FormPaint(Sender: TObject);
begin
   if not drawit then exit;
   DrawBorder(BoardBox.BoundsRect,currentcase.screenparams,canvas);
end;


{************************* TForm1.ExpandMove ************************}
Procedure tForm1.expandmove(move:string;var n:integer;
            var dir:TDirection; var dist:integer);
{Take string versiob of a move and  extract vehicle #, direction and distance}
  var
    errcode:integer;
Begin
  n:=ord(move[1])-ord(pred('A'));
  case move[2] of
    'L': dir:=lefft;
    'R': dir:=right;
    'U': dir:=up;
    'D': dir:=down;
  end;
  val(move[3],dist,errcode);
end;

{*********************** TForm1.Timer1Timer *****************}
procedure TForm1.Timer1Timer(Sender: TObject);
{Timer pops used to show animated program solutions}
var
  mousepoint,cursorpoint:tpoint;
begin
  with currentcase do
    if autodist=0 then
    {move complete, get next move}
    begin
      updatemoveslabel;
      inc(nextmove);
      if nextmove<winningmoves.count then
      Begin
        expandmove(winningmoves[nextmove],dragvehicle,dragdirection,autodist);
      end;
    end;
    if autodist>0 then
    with currentcase.vehicles[dragvehicle] do
    Begin
      cursorpoint.x:=column;
      cursorpoint.y:=row;
      mousepoint:=cursorpoint;
      case dragdirection of
        lefft: mousepoint.x:=column-1;
        right: mousepoint.x:=column+1;
        up: mousepoint.y:=row-1;
        down: mousepoint.y:=row+1;
      end;
      mousepoint:=ConvertRowColToScreen(mousepoint);
      automousemove(true); {move vehicle one square}
      dec(autodist);
    end
    else
    begin
      timer1.enabled:=false;
      dragging:=false;
      screen.cursor:=crdefault;
      Speedbar.visible:=false; SpeedLbl.visible:=false;
    end;
  end;

{************************ TForm1.SolveItClick ********************}
Procedure TForm1.SolveItclick(sender:Tobject);
{var
  p1,p2:integer;} {debug variables}

Begin
  setbtns(false);
  msgcount:=0;
  {p1:=allocmemsize;}{debug memory leak}
  Makewinningmoveslist(winningmoves);
  {p2:=allocmemsize;}
  {listbox2.items.add('Before:'+inttostr(p1)+', After:'+inttostr(p2)); }
  If winner then Showsolution
  else showmessage ('Sorry, I''m not smart enough yet to solve this problem!');
  setbtns(true);
end;


{*************************** TForm1.ShowSolution ****************}
Procedure TForm1.Showsolution;
Begin
  if winningmoves.count>0 then
  begin
    nextmove:=0;
    expandmove(winningmoves[nextmove],dragvehicle,dragdirection,autodist);
    if SoundOn.Checked then
    with mediaplayer1 do
    Begin
      filename:=extractfilepath(application.exename)+'carmove.wav';
        try   open;
          except
            showmessage(errormessage+#13+'Email Grandpa');
            SoundOn.Checked:=false;
        end;
    end;
    speedbar.visible:=true;  speedlbl.visible:=true;
    speedbar.setfocus;
    dragging:=true;
    timer1.interval:=10000 div speedbar.position;
    timer1.enabled:=true;
  end;
end;


 {**************** TForm1.GetHead ********************}
  function TForm1.gethead(const n:integer; const board:TBoardArray):tpoint;
  {get head point for vehicle n}
  var
    i,j:integer;
  Begin
    i:=1;
    j:=0;
    result.x:=0;
    result.y:=0;
    Begin
      {find vehicle on board}
      repeat
        inc(j);
        if j>maxdim then
        begin
          inc(i);
          j:=1;
        end
      until (i>maxdim) or (board[i,j]=n);
      if (i<=maxdim) then
      Begin
        result.y:=j;
        result.x:=i;
      end;
    end;
  end; {gethead}


{********************* TForm1.TrackBar1Change ****************}
procedure TForm1.SpeedBarChange(Sender: TObject);
{ Change Vehicle move speed while autosolving }
begin
  if timer1.enabled then timer1.interval:=10000 div speedbar.position;
end;

{***************************TForm1.FormCreate *********************}
procedure TForm1.FormCreate(Sender: TObject);
Begin
   currentcase:=tcase.create(self);
   randomize;
   firstwidth:=width;
   firstheight:=height;
   winningMoves:=TStringlist.create;
   drawit:=false;
end;

{*********************** TForm1.FormResize ****************}
procedure TForm1.FormResize(Sender: TObject);
{called when form is resized}
var
  r,rw,rh:single;
  i,j:integer;
begin
  if application.terminated then exit;
  rw:=width/firstwidth;
  rh:=height/firstheight;
  if rw>rh then r:=rh else  r:=rw;
  for i:=0 to controlcount-1 do
  with controls[i] do
  Begin
    left:=round(r*left);
    top:=round(r*top);
    height:=(round(r*height) div maxdim)*maxdim;
    width:=(round(r*width) div maxdim)*maxdim;
    font.size{height}:=round(r*font.size{height});

    if (controls[i] is tpanel) then
    with controls[i] as tpanel do
    for j:=0 to controlcount-1 do
      if (controls[j] is tlabel) then
      with controls[j] as tlabel do
      Begin

       left:=round(r*left);
       top:=round(r*top);
       height:=round(r*height);
       width:=round(r*width);

       font.size{height}:=round(r*font.size{height});
     end;
  end;
  firstwidth:=width;
  firstheight:=height;
  if assigned(cases) and (cases.count>0) then loadcurrentcase(currentcasenbr);
end;

{******************** TForm1.NextJamBtnClick *****************}
procedure TForm1.NextJamBtnClick(Sender: TObject);
begin
  inc(currentcasenbr);
  LoadCurrentCase(currentcasenbr);
end;



{****************** TForm1.SetBtns *************}
Procedure TForm1.setbtns(enable:boolean);
Begin
  if enable then
  Begin
    hintbtn.enabled:=true;
    solvebtn.enabled:=true;
    {put it back the way it was}
    if undobtn.tag=1 then  undobtn.enabled:=true
    else undobtn.enabled:=false;
  end
  else
  Begin
    hintbtn.enabled:=false;
    solvebtn.enabled:=false;
    if undobtn.enabled then undobtn.tag:=1 else undobtn.tag:=0;
    undobtn.enabled:=false;
  end;
end;

{******************* TForm1.HintBtnClick ********************}
procedure TForm1.HintBtnClick(Sender: TObject);
var
  m,test:string;
  templist:TStringlist;
begin
  templist:=TStringlist.create;
  Makewinningmoveslist(templist);
  if templist.count>0 then
  begin
    setbtns(false);
    m:=templist[0];
    makemove(m);
    pause(500);
    test:=m;
    case m[2] of
      'L': test[2]:='R';
      'R': test[2]:='L';
      'U': test[2]:='D';
      'D': test[2]:='U';
    end;
    makemove(test);
    dec(blockmovecount,2*(ord(test[3])- ord('0')));
    dec(vehiclemovecount,1);
    updatemoveslabel;
    setbtns(true);
  end
  else showmessage('I don''t think this case is solvable');
  templist.free;
end;

{***************** TForm1.About1Click ***********}
procedure TForm1.About1Click(Sender: TObject);
begin  AboutBox.showmodal; end;

{**************** TForm1.HintsOnClick ************}
procedure TForm1.HintsOnClick(Sender: TObject);
begin
  HintsOn.checked:=not HintsOn.Checked;
  showHint := HintsOn.Checked;
end;

{**************** TForm1.SoundOnClick ***********}
procedure TForm1.SoundOnClick(Sender: TObject);
begin  SoundOn.Checked:=Not SoundOn.Checked;  end;

{****************** TForm1.RestartThisJamClick *************}
procedure TForm1.RestartthisjamClick(Sender: TObject);
begin  LoadCurrentCase(CurrentCaseNbr);  end;


{******************** TForm1.FormActivate ****************}
procedure TForm1.FormActivate(Sender: TObject);
var
  i,p,index:integer;
  fname:string;
  level,s:string;
  list:TStringlist;
  ini:TInifile;
begin
   windowstate:=wsmaximized;
   if not assigned(loginform) then loginform:=tloginform.Create(application);
   repeat
     LoginForm.ShowModal;
   until length(loginform.Edit1.text)>0;

  Username:=loginform.edit1.text;
  firstwidth:=width;
  firstheight:=height;

  canvas.brush.color:=cldkgray;
  Cases:=TCaseList.create;
  Fname:=extractfilepath(application.exename)+ 'TrafficJams.txt';
  if fileexists(fname) then
  Begin
    Cases.LoadCasesFromTxt(Fname);
    inifile:=extractfilepath(application.exename)+'TrafficJams.ini';
    ini:=TInifile.create(Inifile);
    list:=TStringList.create;
    with ini do
    begin
      readsections(list); {load case name for cases with previously save scores}
      for i:= 0 to list.count-1 do
      begin
        index:=cases.find(list[i]);
        if index>=0 then
        with TCase(cases[index]) do
        begin
          bestCscore.x:=readinteger(list[i],'ComputerScoreVehicles',100);
          bestCScore.y:=readinteger(list[i],'ComputerScoreBlocks',100);
          bestHscore.x:=readinteger(list[i],'BestHumanScoreVehicles',100);
          bestHScore.y:=readinteger(list[i],'BestHumanScoreBlocks',100);
          BestScoreBy:=readString(list[i],'BestScoreBy',bestscoreby);
        end;
      end;
    end;
    ini.free;
    list.free;
    cases.casesetname:=Username;
  end
  else
  Begin
    Showmessage('No jams found, e-mail Grandpa');
    close;
  end;

  {Go through here and delete any invalid cases}
  {otherwise combobox and cases are out of sync}
  i:=0;
  while i<=cases.count-1 do
  with TCase(cases[i]) do
  Begin
    p:=pos('-',casename);
    if p>0 then level:=copy(casename,1,p-1) else level:=casename;
    index:=levelbox.items.indexof(level);
    if index<0 then {make a list of cases for each level, annd attach it as an
                     object to the level lsit entry}
    begin
      list:=tStringlist.create;
      index:=levelbox.items.addobject(level,list);
    end;
    {prefix each case name with string version of case number, just as an easy way
     to retrieve the case later}
    with TStringlist(levelbox.items.objects[index]) do
    Begin
      s:=inttostr(i+1);
      if length(s)=1 then s:='0'+s;
      s:=s+casename;
      add(s);
    end;
    inc(i)
  end;
  with levelbox do
  Begin
    itemindex:=0;
    listbox1.Clear;
    with TStringlist(items.objects[0]) do
    Begin
      for i:=0 to count-1 do
      Begin
        s:=strings[i];
        val(copy(s,1,2),currentcasenbr,p);
        system.delete(s,1,2);
        listbox1.items.add(s);
      end;
      itemindex:=0;
    end;
  end;
  SoundOn.Checked:=true;
  soundbtnclick(sender); {this will flip sounds switch}
  Shownumbers.checked:=true;
  ShowNumbersclick(sender); {this will flip shownumbers}
  currentcasenbr:=1;
  currentcase.assignCase(cases[0]);
  listbox1.itemindex:=0;

  setborderparams;
  drawit:=true;
  listbox1click(sender);  {make initial case display}
end;

{******************* TForm1.MakeMove ***********}
Procedure TForm1.makemove(test:string);
    var
      autodist:integer;
      cursorpoint,mousepoint:TPoint;
    Begin
      expandmove(test,dragvehicle,dragdirection,autodist);
      if autodist>0 then
      with currentcase.vehicles[dragvehicle] do
      begin
        repeat
           valid:=true;
          cursorpoint.x:=column;
          cursorpoint.y:=row;
          mousepoint:=cursorpoint;
          case dragdirection of
            lefft: mousepoint.x:=column-1;
            right: mousepoint.x:=column+1;
            up: mousepoint.y:=row-1;
            down: mousepoint.y:=row+1;
          end;
          mousepoint:=ConvertRowColToScreen(mousepoint);
          automousemove(false); {move vehicle one square, don't look for casesolved}
          dec(autodist);
          pause(timer1.interval);
        until autodist=0;
      end;
    end;

{**************** Tform1.UndoBtnClick ***********}
procedure TForm1.UndoBtnClick(Sender: TObject);
var
  test,m:string;
begin
  setbtns(false);
  if winningmoves.count>0 then
  Begin
    with winningmoves do
    repeat
      m:=strings[count-1];
      test:=m;
      case m[2] of
        'L': test[2]:='R';
        'R': test[2]:='L';
        'U': test[2]:='D';
        'D': test[2]:='U';
      end;
      makemove(test);
      dec(blockmovecount,2*(ord(test[3])- ord('0')));
      delete(count-1);
      if count>0 then m:=strings[count-1] else
      begin
        m:='   ';
        undobtn.enabled:=false;
      end;
    until m[1]<>test[1]; {vehicle changed}
    dec(vehiclemovecount,2);
    updatemoveslabel;
  end;
  setbtns(true);
end;

{****************** TForm1.LevelBoxChange ***********}
procedure TForm1.LevelBoxChange(Sender: TObject);
var
  s:string;
  i,n,p:integer;
begin
  with levelbox do
  Begin
    listbox1.Clear;
    with TStringlist(items.objects[levelbox.itemindex]) do
    for i:=0 to count-1 do
    Begin
      s:=strings[i];
      val(copy(s,1,2),n,p);
      if i=0 then currentcasenbr:=n;
      system.delete(s,1,2);
      listbox1.items.add(s);
    end;
    listbox1.itemindex:=0;
    loadcurrentcase(currentcasenbr);
  end;
end;

{$I MakeWinningMovelist1A.Inc}    {Include find solution code}


procedure TForm1.ShownumbersClick(Sender: TObject);
{Turn vehicle number display on or off}
var i:integer;
begin
  shownumbers.checked:=not shownumbers.checked;
  ShowcarNbrs:=Shownumbers.checked;
  {need to delete all vehicle images to force rebuilding them
   with (or without) numbers the next time they are drawn}
  with currentcase do
  for i:=1 to nbrvehicles do freeandnil(vehicles[i].image);
  invalidate;
end;

procedure TForm1.StaticText1Click(Sender: TObject);
begin
   OpenURL('http://www.delphiforfun.org/'); { *Converted from ShellExecute* }
end;

end.
